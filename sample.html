

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>示例代码 &mdash; NNToolChain  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="bmodel 使用" href="usage/bmodel.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> NNToolChain
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="quickstart/abstract.html">NNToolChain 基本概念介绍</a></li>
<li class="toctree-l1"><a class="reference internal" href="quickstart/abstract.html#id1">版本特性</a></li>
<li class="toctree-l1"><a class="reference internal" href="quickstart/abstract.html#id2">NNToolChain 整体架构</a></li>
<li class="toctree-l1"><a class="reference internal" href="quickstart/install.html">NNToolChain 安装说明</a></li>
<li class="toctree-l1"><a class="reference internal" href="quickstart/install.html#pcie">PCIE模式安装</a></li>
<li class="toctree-l1"><a class="reference internal" href="quickstart/install.html#soc">SoC模式安装</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="usage/bmnetc.html">BMNETC 使用</a></li>
<li class="toctree-l1"><a class="reference internal" href="usage/bmnett.html">BMNETT 使用</a></li>
<li class="toctree-l1"><a class="reference internal" href="usage/bmnetm.html">BMNETM 使用</a></li>
<li class="toctree-l1"><a class="reference internal" href="usage/bmnetp.html">BMNETP 使用</a></li>
<li class="toctree-l1"><a class="reference internal" href="usage/bmlang.html">BMLang 说明</a></li>
<li class="toctree-l1"><a class="reference internal" href="usage/runtime.html">BMRuntime 使用</a></li>
<li class="toctree-l1"><a class="reference internal" href="usage/bmodel.html">bmodel 使用</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">示例代码</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#bmlang-examples">BMLang Examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#example-with-bmlang-python">Example with BMLang Python</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#bmruntime-examples">BMRuntime examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#example-with-basic-c-interface">Example with basic C interface</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">NNToolChain</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>示例代码</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/sample.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="id1">
<h1>示例代码<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<div class="section" id="bmlang-examples">
<h2>BMLang Examples<a class="headerlink" href="#bmlang-examples" title="Permalink to this headline">¶</a></h2>
<div class="section" id="example-with-bmlang-python">
<h3>Example with BMLang Python<a class="headerlink" href="#example-with-bmlang-python" title="Permalink to this headline">¶</a></h3>
<p>This example implements the standard LSTM algorithm independently.
BMLang has two mode: COMPILE mode and DEBUG mode. DEBUG mode is for checking whether the BMLang program is correct or not. COMPILE mode is to generate bmodel.
After COMPILE mode, we can use the BMRuntime to run this lstm bmodel in BMTPU device.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">bmlang</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">class</span> <span class="nc">Lstm</span><span class="p">:</span>
  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_len</span><span class="p">,</span> <span class="n">h_len</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">x_len</span> <span class="o">=</span> <span class="n">x_len</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">h_len</span> <span class="o">=</span> <span class="n">h_len</span>

    <span class="c1">## Vector for recording the reference data, it is of use when using BMLANG_BOTH</span>
    <span class="c1">## We can check the result during compiling</span>
    <span class="c1">## Here is optional</span>
    <span class="c1"># self.refTenVec = bmtfPtrVector()</span>
    <span class="c1"># self.inpTenVec = bmtfPtrVector()</span>

    <span class="c1">## get the coefficient data</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">Ui</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Wi</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Bi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_coeff</span><span class="p">(</span><span class="s1">&#39;lstm_coeff_i&#39;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">Uf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Wf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Bf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_coeff</span><span class="p">(</span><span class="s1">&#39;lstm_coeff_f&#39;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">Uo</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Wo</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Bo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_coeff</span><span class="p">(</span><span class="s1">&#39;lstm_coeff_o&#39;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">Ug</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Wg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Bg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_coeff</span><span class="p">(</span><span class="s1">&#39;lstm_coeff_g&#39;</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">init_coeff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coeff_name</span><span class="p">):</span>
    <span class="n">uSize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_len</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">h_len</span>
    <span class="n">wSize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">h_len</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">h_len</span>
    <span class="n">bSize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">h_len</span>
    <span class="c1">## Here we use random data. In fact, here should use real trained data</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_len</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_len</span><span class="p">),</span> <span class="n">uSize</span><span class="p">)</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">h_len</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">h_len</span><span class="p">),</span> <span class="n">wSize</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">h_len</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">h_len</span><span class="p">),</span> <span class="n">bSize</span><span class="p">)</span>
    <span class="n">bmlang_print</span><span class="p">(</span><span class="s1">&#39;u = &#39;</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
    <span class="n">bmlang_print</span><span class="p">(</span><span class="s1">&#39;w = &#39;</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
    <span class="n">bmlang_print</span><span class="p">(</span><span class="s1">&#39;b = &#39;</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">uArray</span> <span class="o">=</span> <span class="n">floatArray</span><span class="p">(</span><span class="n">uSize</span><span class="p">)</span>
    <span class="n">wArray</span> <span class="o">=</span> <span class="n">floatArray</span><span class="p">(</span><span class="n">wSize</span><span class="p">)</span>
    <span class="n">bArray</span> <span class="o">=</span> <span class="n">floatArray</span><span class="p">(</span><span class="n">bSize</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ui</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">uSize</span><span class="p">):</span>
      <span class="n">uArray</span><span class="p">[</span><span class="n">ui</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">ui</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">wi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">wSize</span><span class="p">):</span>
      <span class="n">wArray</span><span class="p">[</span><span class="n">wi</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="n">wi</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">bi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">bSize</span><span class="p">):</span>
      <span class="n">bArray</span><span class="p">[</span><span class="n">bi</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bi</span><span class="p">])</span>

    <span class="c1">## Create coefficient tensors, including uTensor, wTensor and bTensor</span>
    <span class="c1">## A bmtensor_float params include the name and shapes.</span>
    <span class="c1">## the shape dimension can be 8 at most</span>
    <span class="n">uTensor</span> <span class="o">=</span> <span class="n">bmtensor_float</span><span class="p">(</span><span class="n">coeff_name</span> <span class="o">+</span> <span class="s1">&#39;_u&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_len</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">h_len</span><span class="p">)</span>
    <span class="n">wTensor</span> <span class="o">=</span> <span class="n">bmtensor_float</span><span class="p">(</span><span class="n">coeff_name</span> <span class="o">+</span> <span class="s1">&#39;_w&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">h_len</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">h_len</span><span class="p">)</span>
    <span class="n">bTensor</span> <span class="o">=</span> <span class="n">bmtensor_float</span><span class="p">(</span><span class="n">coeff_name</span> <span class="o">+</span> <span class="s1">&#39;_b&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">h_len</span><span class="p">)</span>
    <span class="c1">## declare these tensors are coefficient tensor</span>
    <span class="c1">## This mean these data are fixed</span>
    <span class="c1">## If not declare, this data must feed during runtime</span>
    <span class="n">uTensor</span><span class="o">.</span><span class="n">set_tensor_type</span><span class="p">(</span><span class="n">COEFF_TENSOR</span><span class="p">)</span>
    <span class="n">wTensor</span><span class="o">.</span><span class="n">set_tensor_type</span><span class="p">(</span><span class="n">COEFF_TENSOR</span><span class="p">)</span>
    <span class="n">bTensor</span><span class="o">.</span><span class="n">set_tensor_type</span><span class="p">(</span><span class="n">COEFF_TENSOR</span><span class="p">)</span>
    <span class="c1">## feed data to these tensors</span>
    <span class="n">uTensor</span><span class="o">.</span><span class="n">fill_data</span><span class="p">(</span><span class="n">uArray</span><span class="p">)</span>
    <span class="n">wTensor</span><span class="o">.</span><span class="n">fill_data</span><span class="p">(</span><span class="n">wArray</span><span class="p">)</span>
    <span class="n">bTensor</span><span class="o">.</span><span class="n">fill_data</span><span class="p">(</span><span class="n">bArray</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">uTensor</span><span class="p">,</span> <span class="n">wTensor</span><span class="p">,</span> <span class="n">bTensor</span>

  <span class="c1">## The following is the LSTM computation decribed by BMLang Operators</span>
  <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">T</span><span class="p">):</span>
    <span class="c1">## Create come intermediate bmtensors for computation</span>
    <span class="c1">## We must set the name, but we can not always set shapes</span>
    <span class="c1">## because the shapes of these intermediate tensors can be inferred</span>
    <span class="n">iTensor</span> <span class="o">=</span> <span class="n">bmtensor_float</span><span class="p">(</span><span class="s1">&#39;i_tensor&#39;</span><span class="p">)</span>
    <span class="n">fTensor</span> <span class="o">=</span> <span class="n">bmtensor_float</span><span class="p">(</span><span class="s1">&#39;f_tensor&#39;</span><span class="p">)</span>
    <span class="n">oTensor</span> <span class="o">=</span> <span class="n">bmtensor_float</span><span class="p">(</span><span class="s1">&#39;o_tensor&#39;</span><span class="p">)</span>
    <span class="n">gTensor</span> <span class="o">=</span> <span class="n">bmtensor_float</span><span class="p">(</span><span class="s1">&#39;g_tensor&#39;</span><span class="p">)</span>
    <span class="n">tmpTensor</span> <span class="o">=</span> <span class="n">bmtensor_float</span><span class="p">(</span><span class="s1">&#39;tmp_tensor&#39;</span><span class="p">)</span>

    <span class="c1">## Create input x tensor, the shape must be set, because it is the input</span>
    <span class="n">xTensor</span> <span class="o">=</span> <span class="n">bmtensor_float</span><span class="p">(</span><span class="s1">&#39;x_tensor&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_len</span> <span class="o">*</span> <span class="n">T</span><span class="p">)</span>
    <span class="c1">## filling the data for input</span>
    <span class="n">xTensor</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="c1">## create a vector to save multiple bm_tensors</span>
    <span class="n">xTenVec</span> <span class="o">=</span> <span class="n">bmtfPtrVector</span><span class="p">()</span>
    <span class="n">s_op_t</span> <span class="o">=</span> <span class="n">SPLIT_OP_t</span><span class="p">()</span> <span class="c1">## OP to use bm_split_float</span>
    <span class="n">s_size</span> <span class="o">=</span> <span class="n">intArray</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>  <span class="c1">## a int array</span>
    <span class="n">xTenList</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">):</span>
      <span class="n">s_xTensor</span> <span class="o">=</span> <span class="n">bmtensor_float</span><span class="p">(</span><span class="s1">&#39;x_tensor_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_len</span><span class="p">)</span>
      <span class="n">xTenList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s_xTensor</span><span class="p">)</span>
      <span class="n">xTenVec</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">xTenList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">this</span><span class="p">)</span>
    <span class="n">s_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">T</span>
    <span class="n">s_op_t</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">s_size</span>
    <span class="c1">#s_op_t.num = T</span>
    <span class="n">s_op_t</span><span class="o">.</span><span class="n">num</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">s_op_t</span><span class="o">.</span><span class="n">axis_</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="n">bm_split_float</span><span class="p">(</span><span class="n">xTensor</span><span class="p">,</span> <span class="n">xTenVec</span><span class="p">,</span> <span class="n">s_op_t</span><span class="p">)</span>

    <span class="c1">## Create other intermediate tensors</span>
    <span class="n">inpTenList</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">inpTenList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xTensor</span><span class="p">)</span>
    <span class="n">phTensor</span> <span class="o">=</span> <span class="n">bmtensor_float</span><span class="p">(</span><span class="s1">&#39;h_tensor_t-1&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">h_len</span><span class="p">)</span>
    <span class="n">inpTenList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">phTensor</span><span class="p">)</span>
    <span class="n">pcTensor</span> <span class="o">=</span> <span class="n">bmtensor_float</span><span class="p">(</span><span class="s1">&#39;c_tensor_t-1&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">h_len</span><span class="p">)</span>
    <span class="n">inpTenList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pcTensor</span><span class="p">)</span>

    <span class="c1">## Recode the input data, it is of use when using BMLANG_BOTH</span>
    <span class="c1">## We can check the result during compiling</span>
    <span class="c1">## Here is optional</span>
    <span class="c1"># for j in range(len(inpTenList)):</span>
    <span class="c1">#  self.inpTenVec.push_back(inpTenList[j].this)</span>

    <span class="n">hTenList</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">):</span>
      <span class="n">hTensor</span> <span class="o">=</span> <span class="n">bmtensor_float</span><span class="p">(</span><span class="s1">&#39;h_tensor_t&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">h_len</span><span class="p">)</span>
      <span class="n">cTensor</span> <span class="o">=</span> <span class="n">bmtensor_float</span><span class="p">(</span><span class="s1">&#39;c_tensor_t&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">h_len</span><span class="p">)</span>

      <span class="n">bm_matrixmul_float</span><span class="p">(</span><span class="n">xTenVec</span><span class="p">[</span><span class="n">t</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ui</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Bi</span><span class="p">,</span> <span class="n">iTensor</span><span class="p">)</span>
      <span class="n">bm_matrixmul_float</span><span class="p">(</span><span class="n">phTensor</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Wi</span><span class="p">,</span> <span class="n">tmpTensor</span><span class="p">)</span>
      <span class="n">bm_add_float</span><span class="p">(</span><span class="n">iTensor</span><span class="p">,</span> <span class="n">tmpTensor</span><span class="p">,</span> <span class="n">iTensor</span><span class="p">)</span>
      <span class="n">bm_active_float</span><span class="p">(</span><span class="n">iTensor</span><span class="p">,</span> <span class="n">iTensor</span><span class="p">,</span> <span class="n">ACTIVE_SIGMOID</span><span class="p">)</span>

      <span class="n">bmlang_print</span><span class="p">(</span><span class="s1">&#39;i gate: &#39;</span><span class="p">,</span> <span class="n">iTensor</span><span class="o">.</span><span class="n">data_at</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

      <span class="n">bm_matrixmul_float</span><span class="p">(</span><span class="n">xTenVec</span><span class="p">[</span><span class="n">t</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">Uf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Bf</span><span class="p">,</span> <span class="n">fTensor</span><span class="p">)</span>
      <span class="n">bm_matrixmul_float</span><span class="p">(</span><span class="n">phTensor</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Wf</span><span class="p">,</span> <span class="n">tmpTensor</span><span class="p">)</span>
      <span class="n">bm_add_float</span><span class="p">(</span><span class="n">fTensor</span><span class="p">,</span> <span class="n">tmpTensor</span><span class="p">,</span> <span class="n">fTensor</span><span class="p">)</span>
      <span class="n">bm_active_float</span><span class="p">(</span><span class="n">fTensor</span><span class="p">,</span> <span class="n">fTensor</span><span class="p">,</span> <span class="n">ACTIVE_SIGMOID</span><span class="p">)</span>

      <span class="n">bm_matrixmul_float</span><span class="p">(</span><span class="n">xTenVec</span><span class="p">[</span><span class="n">t</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">Uo</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Bo</span><span class="p">,</span> <span class="n">oTensor</span><span class="p">)</span>
      <span class="n">bm_matrixmul_float</span><span class="p">(</span><span class="n">phTensor</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Wo</span><span class="p">,</span> <span class="n">tmpTensor</span><span class="p">)</span>
      <span class="n">bm_add_float</span><span class="p">(</span><span class="n">oTensor</span><span class="p">,</span> <span class="n">tmpTensor</span><span class="p">,</span> <span class="n">oTensor</span><span class="p">)</span>
      <span class="n">bm_active_float</span><span class="p">(</span><span class="n">oTensor</span><span class="p">,</span> <span class="n">oTensor</span><span class="p">,</span> <span class="n">ACTIVE_SIGMOID</span><span class="p">)</span>

      <span class="n">bm_matrixmul_float</span><span class="p">(</span><span class="n">xTenVec</span><span class="p">[</span><span class="n">t</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ug</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Bg</span><span class="p">,</span> <span class="n">gTensor</span><span class="p">)</span>
      <span class="n">bm_matrixmul_float</span><span class="p">(</span><span class="n">phTensor</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Wg</span><span class="p">,</span> <span class="n">tmpTensor</span><span class="p">)</span>
      <span class="n">bm_add_float</span><span class="p">(</span><span class="n">gTensor</span><span class="p">,</span> <span class="n">tmpTensor</span><span class="p">,</span> <span class="n">gTensor</span><span class="p">)</span>
      <span class="n">bm_active_float</span><span class="p">(</span><span class="n">gTensor</span><span class="p">,</span> <span class="n">gTensor</span><span class="p">,</span> <span class="n">ACTIVE_TANH</span><span class="p">)</span>

      <span class="n">bmlang_print</span><span class="p">(</span><span class="s1">&#39;g gate: &#39;</span><span class="p">,</span> <span class="n">gTensor</span><span class="o">.</span><span class="n">data_at</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

      <span class="n">bm_mul_float</span><span class="p">(</span><span class="n">pcTensor</span><span class="p">,</span> <span class="n">fTensor</span><span class="p">,</span> <span class="n">cTensor</span><span class="p">)</span>
      <span class="n">bm_mul_float</span><span class="p">(</span><span class="n">gTensor</span><span class="p">,</span> <span class="n">iTensor</span><span class="p">,</span> <span class="n">tmpTensor</span><span class="p">)</span>
      <span class="n">bm_add_float</span><span class="p">(</span><span class="n">cTensor</span><span class="p">,</span> <span class="n">tmpTensor</span><span class="p">,</span> <span class="n">cTensor</span><span class="p">)</span>

      <span class="n">bmlang_print</span><span class="p">(</span><span class="s1">&#39;c tensor: &#39;</span><span class="p">,</span> <span class="n">cTensor</span><span class="o">.</span><span class="n">data_at</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

      <span class="n">bm_active_float</span><span class="p">(</span><span class="n">cTensor</span><span class="p">,</span> <span class="n">tmpTensor</span><span class="p">,</span> <span class="n">ACTIVE_TANH</span><span class="p">)</span>
      <span class="n">bm_mul_float</span><span class="p">(</span><span class="n">tmpTensor</span><span class="p">,</span> <span class="n">oTensor</span><span class="p">,</span> <span class="n">hTensor</span><span class="p">)</span>

      <span class="n">bmlang_print</span><span class="p">(</span><span class="s1">&#39;h tensor: &#39;</span><span class="p">,</span> <span class="n">hTensor</span><span class="o">.</span><span class="n">data_at</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

      <span class="n">phTensor</span> <span class="o">=</span> <span class="n">bmtensor_float</span><span class="p">(</span><span class="n">hTensor</span><span class="p">)</span>
      <span class="n">pcTensor</span> <span class="o">=</span> <span class="n">bmtensor_float</span><span class="p">(</span><span class="n">cTensor</span><span class="p">)</span>

      <span class="n">hTenList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hTensor</span><span class="p">)</span>

    <span class="c1">## Recode the reference data, it is of use when using BMLANG_BOTH</span>
    <span class="c1">## We can check the result during compiling</span>
    <span class="c1">## Here is optional</span>
    <span class="c1">## for i in range(len(hTenList)):</span>
    <span class="c1">##   self.refTenVec.push_back(hTenList[i].this)</span>

    <span class="k">return</span> <span class="n">hTenList</span>

<span class="k">def</span> <span class="nf">compile</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
  <span class="c1">## It is of use when using BMLANG_BOTH, it can check result when compiling</span>
  <span class="c1">## When using this, we must turn on sefl.inpTenVec and self.refTenVec above</span>
  <span class="c1"># bmlang_compile_with_result_check(&#39;lstm&#39;, 2, True, self.inpTenVec, self.refTenVec)</span>

  <span class="c1">## The funciton only compile, and generate bmodel</span>
  <span class="n">bmlang_compile</span><span class="p">(</span><span class="s1">&#39;lstm&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">forward_cpu</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">T</span><span class="p">):</span>
  <span class="c1">## Here we can call the cpu implementation for lstm</span>
  <span class="c1">## This is only for debug whether lstm BMLang computation is corrent or wrong</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">lstm</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">result</span>

<span class="n">PYBMLANG_DEBUG</span> <span class="o">=</span> <span class="bp">False</span>
<span class="k">def</span> <span class="nf">bmlang_print</span><span class="p">(</span><span class="o">*</span><span class="n">arg</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">PYBMLANG_DEBUG</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;PYBMLANG LOG: &#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="k">def</span> <span class="nf">debug_mode</span><span class="p">(</span><span class="n">lstm</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">T</span><span class="p">):</span>
  <span class="n">set_mode</span><span class="p">(</span><span class="n">BMLANG_COMPILE</span><span class="p">)</span> <span class="c1"># This only compile</span>
  <span class="c1">## set_mode(BMLANG_BOTH) # This can compile and compare the results</span>
  <span class="n">oupList</span> <span class="o">=</span> <span class="n">lstm</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">inpArray</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
  <span class="n">ref</span> <span class="o">=</span> <span class="n">lstm</span><span class="o">.</span><span class="n">forward_cpu</span><span class="p">(</span><span class="n">inpArray</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
  <span class="n">correct</span> <span class="o">=</span> <span class="n">compare_data</span><span class="p">(</span><span class="n">oupList</span><span class="p">,</span> <span class="n">ref</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">correct</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;LSTM with bmlang is right.&quot;</span><span class="p">)</span>
  <span class="k">else</span> <span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;LSTM with bmlang compuation is wrong&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">compile_mode</span><span class="p">(</span><span class="n">lstm</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">T</span><span class="p">):</span>
  <span class="n">set_mode</span><span class="p">(</span><span class="n">BMLANG_COMPUTE</span><span class="p">)</span> <span class="c1"># This is only for debug whether BMLANG lstm is right or not</span>
  <span class="n">oupList</span> <span class="o">=</span> <span class="n">lstm</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">inpArray</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
  <span class="n">lstm</span><span class="o">.</span><span class="n">compile</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">lstm_main</span><span class="p">(</span><span class="n">xLen</span><span class="p">,</span> <span class="n">hLen</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>
  <span class="c1">## initialize the bmlang</span>
  <span class="n">bmlang_init</span><span class="p">(</span><span class="s1">&#39;BM1682&#39;</span><span class="p">,</span> <span class="n">BMLANG_BOTH</span><span class="p">)</span>
  <span class="n">inp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">xLen</span> <span class="o">*</span> <span class="n">T</span><span class="p">)</span>
  <span class="c1">#inp = np.ones(xLen)</span>
  <span class="n">bmlang_print</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>
  <span class="n">inpArray</span> <span class="o">=</span> <span class="n">floatArray</span><span class="p">(</span><span class="n">xLen</span> <span class="o">*</span> <span class="n">T</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">xLen</span> <span class="o">*</span> <span class="n">T</span><span class="p">):</span>
    <span class="n">inpArray</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">inp</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
  <span class="n">lstm</span> <span class="o">=</span> <span class="n">Lstm</span><span class="p">(</span><span class="n">xLen</span><span class="p">,</span> <span class="n">hLen</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;compile&quot;</span><span class="p">:</span>
    <span class="n">compile_mode</span><span class="p">(</span><span class="n">lstm</span><span class="p">,</span> <span class="n">inpArray</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
  <span class="k">else</span> <span class="p">:</span>
    <span class="n">debug_mode</span><span class="p">(</span><span class="n">lstm</span><span class="p">,</span> <span class="n">inpArray</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
  <span class="c1">## finish bmlang independently</span>
  <span class="n">bmlang_deinit</span><span class="p">()</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
  <span class="n">lstm_main</span><span class="p">(</span><span class="mi">1056</span><span class="p">,</span> <span class="mi">896</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="s2">&quot;compile&quot;</span><span class="p">)</span>
  <span class="n">bmlang_print</span><span class="p">(</span><span class="s1">&#39;LSTM IS FINISHED!&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="bmruntime-examples">
<h2>BMRuntime examples<a class="headerlink" href="#bmruntime-examples" title="Permalink to this headline">¶</a></h2>
<div class="section" id="example-with-basic-c-interface">
<h3>Example with basic C interface<a class="headerlink" href="#example-with-basic-c-interface" title="Permalink to this headline">¶</a></h3>
<p>该example读取网络的reference输入数据，启动inference，最后将TPU inference结果与reference输出数据进行比对。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">bmrt_test</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">//create bmruntime</span>
  <span class="kt">void</span><span class="o">*</span> <span class="n">p_bmrt</span> <span class="o">=</span> <span class="n">create_bmrt_helper</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">CHIPNAME</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span> <span class="n">dev_id</span><span class="p">);</span>

  <span class="c1">// load bmodel</span>
  <span class="n">string</span> <span class="n">bmodel_path</span> <span class="o">=</span> <span class="n">CONTEXT_DIR</span> <span class="o">+</span> <span class="s">&quot;/compilation.bmodel&quot;</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">flag</span> <span class="o">=</span> <span class="n">bmrt_load_bmodel</span><span class="p">(</span><span class="n">p_bmrt</span><span class="p">,</span> <span class="n">bmodel_path</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">flag</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Load bmodel[%s] failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bmodel_path</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>
    <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">//get network number</span>
  <span class="kt">int</span> <span class="n">net_num</span> <span class="o">=</span> <span class="n">bmrt_get_network_number</span><span class="p">(</span><span class="n">p_bmrt</span><span class="p">);</span>

  <span class="kt">char</span> <span class="o">**</span><span class="n">net_names</span><span class="p">;</span>
  <span class="n">bmrt_get_network_names</span><span class="p">(</span><span class="n">p_bmrt</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">***</span><span class="p">)</span><span class="o">&amp;</span><span class="n">net_names</span><span class="p">);</span>
  <span class="n">string</span> <span class="n">input_ref_dir</span> <span class="o">=</span> <span class="n">CONTEXT_DIR</span> <span class="o">+</span> <span class="s">&quot;/&quot;</span> <span class="o">+</span> <span class="n">INPUT_REF_DATA</span><span class="p">;</span>
  <span class="n">string</span> <span class="n">output_ref_dir</span> <span class="o">=</span> <span class="n">CONTEXT_DIR</span> <span class="o">+</span> <span class="s">&quot;/&quot;</span> <span class="o">+</span> <span class="n">OUTPUT_REF_DATA</span><span class="p">;</span>

  <span class="kt">FILE</span><span class="o">*</span> <span class="n">f_input_ref</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">input_ref_dir</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span> <span class="s">&quot;rb&quot;</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="n">f_input_ref</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Error: cannot open file %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">input_ref_dir</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>
    <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kt">FILE</span><span class="o">*</span> <span class="n">f_output_ref</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">output_ref_dir</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span> <span class="s">&quot;rb&quot;</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="n">f_output_ref</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Error: cannot open file %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">output_ref_dir</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>
    <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">const</span> <span class="kt">char</span><span class="o">**</span> <span class="n">input_tensor_names</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">input_tensor_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">char</span><span class="o">**</span> <span class="n">output_tensor_names</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">output_tensor_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">net_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">net_idx</span> <span class="o">&lt;</span> <span class="n">net_num</span><span class="p">;</span> <span class="o">++</span><span class="n">net_idx</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;==&gt; running network #%d: &#39;%s&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">net_idx</span><span class="p">,</span> <span class="n">net_names</span><span class="p">[</span><span class="n">net_idx</span><span class="p">]);</span>
    <span class="c1">//get input tensor and output tensor info</span>
    <span class="n">bmrt_get_input_tensor</span><span class="p">(</span><span class="n">p_bmrt</span><span class="p">,</span> <span class="n">net_idx</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">input_tensor_num</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">input_tensor_names</span><span class="p">);</span>
    <span class="n">bmrt_get_output_tensor</span><span class="p">(</span><span class="n">p_bmrt</span><span class="p">,</span> <span class="n">net_idx</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">output_tensor_num</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">output_tensor_names</span><span class="p">);</span>

    <span class="c1">//alloc input memory</span>
    <span class="kt">int8_t</span><span class="o">**</span> <span class="n">host_input_data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int8_t</span><span class="o">**</span><span class="p">)(</span><span class="k">new</span> <span class="kt">int8_t</span><span class="o">*</span> <span class="p">[</span><span class="n">input_tensor_num</span><span class="p">]);</span>
    <span class="n">bm_device_mem_t</span><span class="o">*</span> <span class="n">dev_input_data</span> <span class="o">=</span> <span class="k">new</span> <span class="n">bm_device_mem_t</span> <span class="p">[</span><span class="n">input_tensor_num</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">in</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ic</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ih</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">iw</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">input_dim</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span> <span class="p">[</span><span class="n">input_tensor_num</span><span class="p">];</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">input_shape</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span> <span class="p">[</span><span class="n">input_tensor_num</span> <span class="o">*</span> <span class="mi">4</span><span class="p">];</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">input_tensor_num</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">//get the shape of the input tensor</span>
      <span class="n">bmrt_get_input_blob_max_nhw</span><span class="p">(</span><span class="n">p_bmrt</span><span class="p">,</span> <span class="n">input_tensor_names</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">net_idx</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">in</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ic</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ih</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iw</span><span class="p">);</span>
      <span class="n">input_dim</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
      <span class="n">input_shape</span><span class="p">[</span><span class="mi">4</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">in</span><span class="p">;</span>
      <span class="n">input_shape</span><span class="p">[</span><span class="mi">4</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ic</span><span class="p">;</span>
      <span class="n">input_shape</span><span class="p">[</span><span class="mi">4</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">ih</span><span class="p">;</span>
      <span class="n">input_shape</span><span class="p">[</span><span class="mi">4</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">iw</span><span class="p">;</span>
      <span class="c1">//get the data type of the input tensor</span>
      <span class="kt">int</span> <span class="n">i_dtype</span> <span class="o">=</span> <span class="n">bmrt_get_input_data_type</span><span class="p">(</span><span class="n">p_bmrt</span><span class="p">,</span> <span class="n">input_tensor_names</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">net_idx</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
      <span class="c1">//malloc host memory for input data</span>
      <span class="n">host_input_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int8_t</span> <span class="p">[</span><span class="n">in</span> <span class="o">*</span> <span class="n">ic</span> <span class="o">*</span> <span class="n">ih</span> <span class="o">*</span> <span class="n">iw</span> <span class="o">*</span> <span class="n">dtype_size</span><span class="p">(</span><span class="n">i_dtype</span><span class="p">)];</span>
      <span class="c1">//read input data from reference</span>
      <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">fread</span><span class="p">(</span><span class="n">host_input_data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">in</span> <span class="o">*</span> <span class="n">ic</span> <span class="o">*</span> <span class="n">ih</span> <span class="o">*</span> <span class="n">iw</span> <span class="o">*</span> <span class="n">dtype_size</span><span class="p">(</span><span class="n">i_dtype</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">f_input_ref</span><span class="p">)))</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Failed to fread reference data for the %d-th input</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="c1">//malloc device memory</span>
      <span class="n">bmrt_malloc_device_byte</span><span class="p">(</span><span class="n">p_bmrt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_input_data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">in</span> <span class="o">*</span> <span class="n">ic</span> <span class="o">*</span> <span class="n">ih</span> <span class="o">*</span> <span class="n">iw</span> <span class="o">*</span> <span class="n">dtype_size</span><span class="p">(</span><span class="n">i_dtype</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="c1">//alloc output memory</span>
    <span class="kt">int8_t</span><span class="o">**</span> <span class="n">host_output_data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int8_t</span><span class="o">**</span><span class="p">)(</span><span class="k">new</span> <span class="kt">int8_t</span><span class="o">*</span> <span class="p">[</span><span class="n">output_tensor_num</span><span class="p">]);</span>
    <span class="kt">int8_t</span><span class="o">**</span> <span class="n">ref_output_data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int8_t</span><span class="o">**</span><span class="p">)(</span><span class="k">new</span> <span class="kt">int8_t</span><span class="o">*</span> <span class="p">[</span><span class="n">output_tensor_num</span><span class="p">]);</span>
    <span class="n">bm_device_mem_t</span><span class="o">*</span> <span class="n">dev_output_data</span> <span class="o">=</span> <span class="k">new</span> <span class="n">bm_device_mem_t</span> <span class="p">[</span><span class="n">output_tensor_num</span><span class="p">];</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">on</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span> <span class="p">[</span><span class="n">output_tensor_num</span><span class="p">];</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">oc</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span> <span class="p">[</span><span class="n">output_tensor_num</span><span class="p">];</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">oh</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span> <span class="p">[</span><span class="n">output_tensor_num</span><span class="p">];</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">ow</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span> <span class="p">[</span><span class="n">output_tensor_num</span><span class="p">];</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">o_dtpye</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span> <span class="p">[</span><span class="n">output_tensor_num</span><span class="p">];</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">output_tensor_num</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">//get the shape of the output tensor</span>
      <span class="n">bmrt_get_output_blob_max_nhw</span><span class="p">(</span><span class="n">p_bmrt</span><span class="p">,</span> <span class="n">output_tensor_names</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">net_idx</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
                                   <span class="o">&amp;</span><span class="n">on</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">oc</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">oh</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">ow</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
      <span class="c1">//get the data type of the output tensor</span>
      <span class="n">o_dtpye</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">bmrt_get_output_data_type</span><span class="p">(</span><span class="n">p_bmrt</span><span class="p">,</span> <span class="n">output_tensor_names</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">net_idx</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
      <span class="n">host_output_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int8_t</span> <span class="p">[</span><span class="n">on</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">oc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">oh</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">ow</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">dtype_size</span><span class="p">(</span><span class="n">o_dtpye</span><span class="p">[</span><span class="n">i</span><span class="p">])];</span>
      <span class="n">ref_output_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int8_t</span> <span class="p">[</span><span class="n">on</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">oc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">oh</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">ow</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">dtype_size</span><span class="p">(</span><span class="n">o_dtpye</span><span class="p">[</span><span class="n">i</span><span class="p">])];</span>
      <span class="c1">//read output data from reference</span>
      <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">fread</span><span class="p">(</span><span class="n">ref_output_data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">on</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">oc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">oh</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">ow</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">dtype_size</span><span class="p">(</span><span class="n">o_dtpye</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
                 <span class="mi">1</span><span class="p">,</span> <span class="n">f_output_ref</span><span class="p">)))</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Failed to fread reference data for the %d-th output</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="c1">//malloc device memory</span>
      <span class="n">bmrt_malloc_device_byte</span><span class="p">(</span><span class="n">p_bmrt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_output_data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
          <span class="n">on</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">oc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">oh</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">ow</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">dtype_size</span><span class="p">(</span><span class="n">o_dtpye</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
    <span class="p">}</span>

    <span class="c1">//memcpy input data from system to device</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">input_tensor_num</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">bmrt_memcpy_s2d</span><span class="p">(</span><span class="n">p_bmrt</span><span class="p">,</span> <span class="n">dev_input_data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">host_input_data</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
    <span class="p">}</span>

    <span class="c1">//neuron network inference</span>
    <span class="kt">bool</span> <span class="n">success</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">bmrt_can_batch_size_change</span><span class="p">(</span><span class="n">p_bmrt</span><span class="p">,</span> <span class="n">net_idx</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">||</span>
       <span class="n">bmrt_can_height_and_width_change</span><span class="p">(</span><span class="n">p_bmrt</span><span class="p">,</span> <span class="n">net_idx</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
      <span class="c1">//call inference if input shape can be changed</span>
      <span class="n">success</span> <span class="o">=</span> <span class="n">bmrt_launch_shape</span><span class="p">(</span><span class="n">p_bmrt</span><span class="p">,</span> <span class="n">net_idx</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="n">dev_input_data</span><span class="p">),</span> <span class="n">input_tensor_num</span><span class="p">,</span> <span class="n">input_dim</span><span class="p">,</span> <span class="n">input_shape</span><span class="p">,</span>
                                <span class="p">(</span><span class="k">const</span> <span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="n">dev_output_data</span><span class="p">),</span> <span class="n">output_tensor_num</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">//call inference if input shape cannot changed</span>
      <span class="n">success</span> <span class="o">=</span> <span class="n">bmrt_launch</span><span class="p">(</span><span class="n">p_bmrt</span><span class="p">,</span> <span class="n">net_idx</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="n">dev_input_data</span><span class="p">),</span> <span class="n">input_tensor_num</span><span class="p">,</span>
                            <span class="p">(</span><span class="k">const</span> <span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="n">dev_output_data</span><span class="p">),</span> <span class="n">output_tensor_num</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">success</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;The %d-th neuron network &#39;%s&#39; inference failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">net_idx</span><span class="p">,</span> <span class="n">net_names</span><span class="p">[</span><span class="n">net_idx</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="c1">//sync, wait for finishing inference</span>
    <span class="n">bmrt_thread_sync</span><span class="p">(</span><span class="n">p_bmrt</span><span class="p">);</span>

    <span class="c1">//memcpy output data from device to system</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">output_tensor_num</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">bmrt_memcpy_d2s</span><span class="p">(</span><span class="n">p_bmrt</span><span class="p">,</span> <span class="n">host_output_data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dev_output_data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="c1">//get true performance time</span>
    <span class="kt">long</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">last_api_process_time_us</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">bmrt_get_last_api_process_time_us</span><span class="p">(</span><span class="n">p_bmrt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">last_api_process_time_us</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;the last_api_process_time_us is %lu us</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">last_api_process_time_us</span><span class="p">);</span>

    <span class="c1">//compare inference output data with reference data</span>
    <span class="kt">int</span> <span class="n">flag</span> <span class="o">=</span> <span class="n">result_cmp</span><span class="p">(</span><span class="n">host_output_data</span><span class="p">,</span> <span class="n">ref_output_data</span><span class="p">,</span> <span class="n">output_tensor_num</span><span class="p">,</span> <span class="n">on</span><span class="p">,</span> <span class="n">oc</span><span class="p">,</span> <span class="n">oh</span><span class="p">,</span> <span class="n">ow</span><span class="p">,</span> <span class="n">o_dtpye</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">flag</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;+++ The %d-th network &#39;%s&#39; cmp failed +++</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">net_idx</span><span class="p">,</span> <span class="n">net_names</span><span class="p">[</span><span class="n">net_idx</span><span class="p">]);</span>
      <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;+++ The %d-th network &#39;%s&#39; cmp success +++</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">net_idx</span><span class="p">,</span> <span class="n">net_names</span><span class="p">[</span><span class="n">net_idx</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="c1">//free tensor name</span>
    <span class="n">free</span><span class="p">(</span><span class="n">input_tensor_names</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">output_tensor_names</span><span class="p">);</span>
    <span class="c1">//free memory</span>
    <span class="k">delete</span> <span class="p">[]</span> <span class="n">dev_input_data</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">input_tensor_num</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">delete</span> <span class="p">[]</span> <span class="n">host_input_data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">delete</span> <span class="p">[]</span> <span class="n">host_input_data</span><span class="p">;</span>
    <span class="k">delete</span> <span class="p">[]</span> <span class="n">dev_output_data</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">output_tensor_num</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">delete</span> <span class="p">[]</span> <span class="n">host_output_data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
      <span class="k">delete</span> <span class="p">[]</span> <span class="n">ref_output_data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">delete</span> <span class="p">[]</span> <span class="n">host_output_data</span><span class="p">;</span>
    <span class="k">delete</span> <span class="p">[]</span> <span class="n">ref_output_data</span><span class="p">;</span>
    <span class="k">delete</span> <span class="p">[]</span> <span class="n">on</span><span class="p">;</span>
    <span class="k">delete</span> <span class="p">[]</span> <span class="n">oc</span><span class="p">;</span>
    <span class="k">delete</span> <span class="p">[]</span> <span class="n">oh</span><span class="p">;</span>
    <span class="k">delete</span> <span class="p">[]</span> <span class="n">ow</span><span class="p">;</span>
    <span class="k">delete</span> <span class="p">[]</span> <span class="n">o_dtpye</span><span class="p">;</span>
    <span class="k">delete</span> <span class="p">[]</span> <span class="n">input_dim</span><span class="p">;</span>
    <span class="k">delete</span> <span class="p">[]</span> <span class="n">input_shape</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">free</span><span class="p">(</span><span class="n">net_names</span><span class="p">);</span>
  <span class="n">fclose</span><span class="p">(</span><span class="n">f_input_ref</span><span class="p">);</span>
  <span class="n">fclose</span><span class="p">(</span><span class="n">f_output_ref</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="usage/bmodel.html" class="btn btn-neutral float-left" title="bmodel 使用" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Sophon

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>